# 需求和背景
1. 除了中国之外，以见科技在世界很多国家和地方都有项目。  
2. 为了快速浏览和定位，我们需要一张世界地图。地图上有一些简单的交互。  
3. 我们至少需要中国的省份(边界)信息和外国的国家(边界)信息。  
4. 地图需要支持3D。
# 问题
## 国内地图问题
在国内，最便捷的方法是调用高德或腾讯地图的API来构建地图应用。 但它们的问题是国外的地理数据基本为0. 这也是为什么我们出了国就得换地图APP.
## 国外地图问题
这里说的国外地图，指的是google map这些online的地图。调它们的地图API来构建应用也方便，只是有些没法访问，有些访问速度太慢。此外还有敏感地缘问题和疆域划分问题所带来的巨大风险。
## 其他问题
我们不希望我们的地理空间数据放在互联网上等安全问题。

# 解决方案
基于上述背景和问题考量，我们需要一个离线的，自己部署(self-host)的地图应用服务器。  
地图应用最重要的是地理数据。我们需要从OpenStreetMap等开源数据库里下载数据，当然我们只需要中国和所需要国家的地图数据来构建底图。此外我们需要对数据作必要的调整，尤其是中国部分，疆域划分需要和腾讯/高德地图对齐。

# OpenMapTiles
[OpenMapTiles Doc](https://openmaptiles.org/docs/)
## 下载上海mbtiles
[矢量数据或栅格数据下载地址](https://data.maptiler.com/downloads/planet/)
```shell
wget -c https://data.maptiler.com/download/WyIwYWQzMWUyMi1mODI0LTRjYjctYmQwMy1iMmNhMjNiNDA4MjYiLCItMSIsODczMl0.YvyQiQ.tPVEJEs7E44c0jtc0HQj7lBqk5w/maptiler-osm-2017-07-03-v3.6.1-china_shanghai.mbtiles?usage=personal
```
这是2017年的数据，77M大小的矢量数据。
## 运行 tile server
需要最新的node环境, 我们用 v18.7.0  
```shell
npm install -g tileserver-gl-light
tileserver-gl-light 2017-07-03_china_shanghai.mbtiles
```
这样我们的map server就好了。

# TileServer GL
TileServer GL是一个开源的tile server，由瑞士的一家公司开发和维护。开发语言是JavaScript和Node.js,代码在[https://github.com/maptiler/tileserver-gl](https://github.com/maptiler/tileserver-gl)
## 下载数据
我们从OpenStreetMap下载数据。整个世界地图的数据是51G,我们先下载上海数据。但是从OpenStreeMap下载下来的是原始数据，TileServer GL读不了，需要把它转成mbtiles文件。这是一个耗时的过程，索性可以从 [https://data.maptiler.com/downloads/planet/](https://data.maptiler.com/downloads/planet/) 直接下载mbtiles.
## web工程访问地图
Tile server搭好后，就可以开发web应用来使用地图数据。
## OpenStreetMap数据转mbtiles
TileServer GL是不能直接读OpenStreeMap原始数据的，需要把它转成mbtiles. 那我们怎么转呢？  

## MapLibre GL JS
[https://maplibre.org/maplibre-gl-js-docs/api/](https://maplibre.org/maplibre-gl-js-docs/api/)
示例html代码
```html
<script src='maplibre-gl.js'></script>
<link href='maplibre-gl.css' rel='stylesheet' />

<div id='map' style='width: 1080px; height: 720px;'></div>
<script>
  var map = new maplibregl.Map({
    container: 'map',
    style: 'http://developer.yijianar.com:8898/styles/basic-preview/style.json',
    // center: [121.53023,31.273854],
    // center: [121.317115,31.164686],
    center: [121.528525,31.274476666666665],
    zoom:17
  });
  var marker = new maplibregl.Marker().setLngLat([121.528525,31.274476666666665]).addTo(map);
</script>
```
注意，这里的style用前面搭好的tileserver地址。 center和marker坐标都来自树莓派的GPS模块。  
![https://pro-developer.oss-cn-shanghai.aliyuncs.com/74/img/1660816146405_rpimap.png](https://pro-developer.oss-cn-shanghai.aliyuncs.com/74/img/1660816146405_rpimap.png)

## HTTPS重定向
tileserver-gl-light运行得到的style.json的地址是http. 这很多时候会不兼容于现今的一些web框架和站点。我们需要用Nginx把HTTP重定向到HTTPS.
### 重定向所有80端口
```shell
server {
  listen 80 default_server;
  server_name _;
  return 301 https://$host$request_uri;
}
```
### 重定向特定地址
```shell
server {
  listen 80;
  server_name foo.com;
  return 301 https://foo.com$request_uri;
}
```

# 树莓派上传GPS
我们采用树莓派WEB API穿透，WEB前端轮询的方式。
## 树莓派穿透
我们用SSH Remote Port Forwarding.  
在dev服务器dev.yijianar.com上改一下sshd_config
```shell
AllowTcpForwarding yes
GatewayPorts yes
```
在树莓派里
```shell
ssh -R 8444:127.0.0.1:8443 dev@dev.yijianar.com
```
就能把树莓派里通过8443端口提供的api服务转发到dev的8444端口. 实际部署时加上-N -f两个选项。
## HTTPS
我们开发的时候用的是HTTP,部署时需要HTTPS.
```python
app.run(host='0.0.0.0',port='8443',ssl_context=('yijian.pem','yijian.key'))
```
yijian.pem,yijian.key是服务器dev的HTTPS证书。
这样用户就能通过
```shell
curl https://dev.yijianar.com:8444/hello
```
来访问树莓派的https服务.
## 生产者消费者模式
这里我们用到了经典的生产者消费者设计模式。  
producer.py负责生产数据，存储到redis. 而flask app的api接口则扮演消费者，从redis里取数据。  
前端按照既定频率调接口取数据，再显示到地图上就可以了。
## 获取设备的坐标
```shell
curl "https://dev.yijianar.com/api/gpsconsume?serial=1000000059a5a9ff&points=5"
```
serial表示设备序列号，points表示返回最近的几个点. 如果不赋值，则返回所有点。
返回数据的格式是 经度;纬度;高度;航向角;航向角状态;卫星数;解状态;数据采集时间
```json
[
  "121.52818616366667;31.27387373883333;20.5370;-9999;0;14;5 (浮动解,可用);2022-09-02 15:03:23", 
  "121.52818622000001;31.273873734000006;20.5549;-9999;0;14;5 (浮动解,可用);2022-09-02 15:03:23", 
  "121.52818609033334;31.27387363333333;20.5370;-9999;0;14;5 (浮动解,可用);2022-09-02 15:03:24", 
  "121.52818609033334;31.27387363333333;20.5370;-9999;0;14;5 (浮动解,可用);2022-09-02 15:03:24", 
  "121.52818609033334;31.27387363333333;20.5370;-9999;0;14;5 (浮动解,可用);2022-09-02 15:03:24"
]
```
## 上传设备坐标
上传的文件名为serial_name.txt，即以设备编号/设备名来命名的txt文件。文件的每一行以(timestamp,lng,lat,height)为格式的数据。如 
```shell
2022-09-02 15:03:23, 121.52818622000001, 31.273873734000006, 20.5549
2022-09-07 08:45:01, 1, 2, 3
2022-08-14 07:34:48, 4, 5, 6
```
```shell
curl -F txt=@a.txt https://dev.yijianar.com/api/upload_gps_txt
```
## rtk设备列表
```shell
curl https://beta-dev.yijianar.com/api/rtkbox_list
```
```json
[
  {
    "id": "RTK000",
    "serialnum": "1000000059a5a9ff",
    "proddate": "None",
    "hwversion": "单天线",
    "swversion": "单线程",
    "qxaccount": null,
    "qianxun": "cXhubm1zMDA1OmQxMWY1Mjk=\r\n\r\n",
    "simcard": null,
    "simowner": "黄国政",
    "port": null,
    "project": "办公室测试",
    "projcycle": null,
    "remark": "办公室测试"
  },
  {
    "id": "RTK001",
    "serialnum": null,
    "proddate": "2021-07-01",
    "hwversion": "单天线",
    "swversion": "多线程",
    "qxaccount": "qxnnms004",
    "qianxun": null,
    "simcard": "17821760608",
    "simowner": "刘敏",
    "port": null,
    "project": "温州机场",
    "projcycle": "2年",
    "remark": null
  },
  {
    "id": "RTK002",
    "serialnum": null,
    "proddate": "2021-08-01",
    "hwversion": "单天线(支持双天线)",
    "swversion": "中继站",
    "qxaccount": "qxnnms005",
    "qianxun": null,
    "simcard": "13774310912",
    "simowner": "刘敏",
    "port": null,
    "project": "bimbox",
    "projcycle": null,
    "remark": "回到办公室，有损坏"
  },
  {
    "id": "RTK003",
    "serialnum": null,
    "proddate": "2022-02-01",
    "hwversion": "单天线",
    "swversion": "单线程",
    "qxaccount": "qxnnms005",
    "qianxun": null,
    "simcard": "17701274402",
    "simowner": "吴致远",
    "port": null,
    "project": "拉萨机场",
    "projcycle": null,
    "remark": "目前在深圳; 回到办公室"
  },
  {
    "id": "RTK004",
    "serialnum": null,
    "proddate": "2022-03-01",
    "hwversion": "单天线(支持双天线)",
    "swversion": "单线程",
    "qxaccount": "qxnnms005",
    "qianxun": null,
    "simcard": "18317089177",
    "simowner": "刘敏",
    "port": null,
    "project": "办公室自用",
    "projcycle": null,
    "remark": "目前主要测试机; 寄到深圳赵志豪"
  }
]
```
## WEB远程控制RTK
一般远程控制机子，我们会用SSH登录控制。只是web/javascript没有直接的ssh协议。  
所以我们在web client通过HTTP request发送给Server, Server再通过Python执行SSH shutdown/reboot来控制RTKbox的关机与重启。  
这之前，我们需要先把Server的id_rsa.pub里的key拷贝至RTKbox的~/.ssh/authorized_keys. 如果Server的~/.ssh/里没有id_rsa.pub,则执行ssh-keygen先生成。这样就可以做到密钥直接登录而不是密码登录。其次，RTKbox做好穿透。
### 关机
```shell
curl -X POST -d '{"serialnum":"1000000059a5a9ff","port":8202}' https://dev.yijianar.com/api/rtkbox_shutdown
```
### 重启
```shell
curl -X POST -d '{"serialnum":"1000000059a5a9ff","port":8202}' https://dev.yijianar.com/api/rtkbox_reboot
```
## 查询坐标生成轨迹
```shell
curl -X POST -d '{"serials":["1000000059a5a9ff"],"starttime":"2022-09-01 17:37:27","endtime":"2022-10-01 17:37:27"}' https://dev.yijianar.com/api/gpsquery
```
