subprocess模块可以让你衍生新的进程，连接他们的input/output/error pipes,以及拿到他们的return code.  
推荐的触发子进程的方式是用run()函数。对于更高级的案例，可以用它下层的Popen接口。  
```python
subprocess.run(args,*,stdin=None,input=None,stdout=None,stderr=None,capture_output=False,shell=False,cwd=None,timeout=None,...)
```
完整的函数signature和Popen构造器很相似。
```python
subprocess.run(["ls","-l"])
subprocess.run("exit 1", shell=True, check=True)
```

# Examples
```python
import subprocess
# run and capture output
process = subprocess.run(['ls','-lha'],check=True,stdout=subprocess.PIPE,universal_newlines=True)
output = process.stdout
output

# run raw string as shell command
process = subprocess.run('ls -lha',shell=True,check=True,stdout=subprocess.PIPE,universal_newlines=True)
output = process.stdout
output

# run and get return code
cp = subprocess.run(['ls','-lha'])
cp

# force exception if process errors
subprocess.run(["ls","foo bar"],check=True)

# store output message
cp = subprocess.run(["ls","-lha"], universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
cp.stdout
cp.stderr
cp.returncode
```

Popen is used for more complex examples

```python
from subprocess import Popen

# get return code
p = Popen(["ls","-lha"])
p.wait() #0

# store output message
p = Popen(["ls","-lha"],stdout=subprocess.PIPE,stderr=subprocess.PIPE,universal_newlines=True)
output, errors = p.communicate()
output
errors

# redirect output to file
output_file_path = '/tmp/myoutput.txt'
myoutput = open(output_file_path)
p = Popen(["ls","-lha"],stdout=myoutput,stderr=subprocess.PIPE,universal_newlines=True)
output, errors = p.communicate()
output
errors
with open(output_file_path,"r") as f:
  print(f.read())

# run command in background
# By default, calls to Popen() spawn a subprocess in the background and don't wait for it to terminate(unless you use wait() on the Popen object)
```
# Killing subprocess
## Method 1: use Group ID
```python
# write_to_file.py
import time
n = 2
with open("out.txt","w+") as f:
  for i in range(n):
    f.write(f"{i}\n")
    time.sleep(10)
```
```python
# another.py
import subprocess
pro = subprocess.Popen("python3 write_to_file.py",stdout=subprocess.PIPE,shell=True,start_new_session=True)
print("Process iD:",pro.pid)
pro.kill()
```
